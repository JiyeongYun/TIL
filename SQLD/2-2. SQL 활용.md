# 2-2. SQL 활용

### 제 1절. 표준조인 및 집합 연산자

##### 집합 연산자

- 두개 이상의 테이블에서 조인을 사용하지 않고 연관된 데이터를 조회할 때 사용
- SELECT 절의 컬럼 수가 동일하고, SELECT절의 동일 위치에 존재하는 컬럼의 데이터 타입이 상호 호환할 때 사용 가능



##### 일반 집합 연산자

```sql
1. UNION		-- 합집합(중복 행 1개로) 정렬
2. UNION ALL	-- 합집합(중복 행 1개로) 정렬 X
3. INTERSECT	-- 교집합(중복 행 1개로)
4. MINUS		-- 차집합(중복 행 1개로)
5. CROSS JOIN	-- 곱집합(PRODUCT)

-- ALIAS는 처음 테이블, 정렬은 마지막 테이블 기준
```



##### 순수 관계 연산자: 관계형 DB를 새롭게 구현

```sql
SELECT			-- WHERE절로 구현
PROJECT			-- SELECT절로 구현
NATURAL JOIN	-- 다양한 JOIN으로 구현
DIVIDE			-- 사용 X
{a,x}{a,y}{a,z} divide {x,z} = {a}
```



##### FROM절 JOIN 형태

1. INNER JOIN
2. NATURAL JOIN
3. USING 조건절
4. ON 조건절
5. CROSS JOIN
6. OUTER JOIN



##### INNER JOIN

- JOIN 조건에서 **<u>동일한 값이 있는 행</u>**만 반환
- **<u>USING이나 ON절</u>**을 필수적으로 사용



##### NATURAL JOIN

- 두 테이블 간의 **<u>동일한 이름을 갖는 모든 컬럼</u>**들에 대해 EQUI JOIN 수행
- NATURAL JOIN이 명시되면 추가로 USING, ON, WHERE절에서 JOIN 조건을 정의할 수 없음
- SQL Server는 지원 안 함.



##### USING 조건절

- 같은 이름을 가진 컬럼들 중에서 원하는 컬럼에 대해서만 선택적으로 EQUI JOIN 가능
- JOIN 컬럼에 대해 ALIAS나 테이블 이름과 같은 접두사를 붙일 수 없음
- SQL Server는 지원 안 함.



##### ON 조건절

- ON 조건절과 WHERE 조건절을 분리하여 이해가 쉬우며 컬럼명이 다르더라도 JOIN 조건을 사용할 수 있는 장점이 있음
- **<u>ALIS나 테이블명 반드시 사용</u>**



##### CROSS JOIN = 카타시안 곱

- 양쪽 집합의 M*N건의 데이터 조합이 발생



##### OUTER JOIN(LEFT, RIGHT, FULL)

- JOIN 조건에서 동일한 값이 없는 행도 반환 가능
- **<u>USING이나 ON 조건절</u>** 반드시 사용해야 함.
- SQL식에서 (+) 안 붙은 쪽으로 JOIN한다.
- **LEFT OUTER JOIN**
  - 먼저 표기된 좌측 텡블에 해당하는 데이터를 읽은 후 나중 표기된 우측 테이블에서 JOIN 대상 데이터를 읽어온다.
  - 우측 값에서 같은 값이 없는 경우 NULL 값으로 채움
- **RIGHT OUTER JOIN**
  - LEFT OUTER JOIN의 반대
- **FULL OUTER JOIN**
  - 좌우측 테이블의 모든 데이터를 읽어 JOIN하여 결과 생성
  - 중복 데이터는 삭제



---

### 제 2절. 계층형 질의

 ##### 계층의 질의

- 테이블에 계층형 데이터가 존재하는 경우 데이터를 조회하기 위해 사용

```sql
START WITH			-- 계층 구조 전개의 시작 위치 지정
CONNECT BY			-- 다음에 전개될 자식 데이터 지정
PRIOR				-- CONNECT BY 절에 사용되며, 현재 읽은 칼럼을 지정
					-- PRIOR 자식 = 부모 형태를 사용하면 
					-- 계층구조에서 부모 데이터에서 자식데이터(부->자) 방향으로 전개하는 순방향 전개
                    -- 반대는 역방향 전개	
NOCYCLE				-- 동일한 데이터가 전개되지 않음
ORDER SIBLINGS BY 	-- 형제 노드간의 정렬 수행
WHERE				-- 모든 전개를 수행한 후에 지정된 조건을 만족하는 데이터만 추출(필터링)


LEVEL					-- 루트 데이터이면 1, 그 하위 데이터이면 2, 리프데이터까지 1씩 증가 
CONNECT_BY_ISLEAF		-- 해당 데이터가 리프데이터면 1, 그렇지 않으면 0
CONNECT_BY_ISCYCLE		-- 해당 데이터가 조상이면 1, 아니면 0(CYCLE 옵션 사용했을 때만 사용 가능)
SYS_CONNECT_BY_PATH		-- 루트 데이터부터 현재 전개할 데이터까지의 경로를 표시
CONNECT_BY_ROOT			-- 현재 전개할 데이터의 루트 데이터를 표시함. 단항 연산자이다.
```





---

### 제 3절. 셀프 조인

- 한 테이블 내 두 컬럼이 연관 관계가 있을 때 동일 테이블 사이의 조인
- FROM 절에 동일 테이블이 2번 이상 나타남
- 반드시 테이블 별칭을 사용해야 함





---

### 제 4절. 서브쿼리

- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문
- 알려지지 않은 기준을 이용한 검색에 사용
- 서브쿼리를 **<u>괄호</u>**로 감싸서 사용
- 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능
- **<u>단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하고, 복수 행 비교 연산자는 결과 건수와 상관없음</u>**
- 서브쿼리에서는 **<u>ORDER BY 사용 못 함</u>**.
- SELECT, FROM, WHERE, HAVING, ORDER BY, INSERT-VALUES, UPDATE-SET 절에 사용 가능



##### 단일 행 비교 연산자: =, <, >, <> 등

##### 다중 행 비교 연산자: IN, ALL, ANY, SOME 등

##### 스칼라 서브쿼리: 한 행, 한 컬럼만을 반환하는 서브 쿼리



##### 동작 방식에 따른 서브쿼리 분류

- **비연관 서브쿼리**: 서브 쿼리가 메인쿼리 컬럼을 안 가짐. 메인쿼리에 값을 제공하는 것이 목적
- **연관 서브쿼리**: 서브쿼리가 메인쿼리 컬럼을 가짐



##### 반환 데이터에 따른 서브쿼리 종류

- **단일행 서브쿼리**: 실행결과 1건 이하
- **다중행 서브쿼리**: 실행결과 여러 건
- **다중 컬럼 서브쿼리**: 실행결과 컬럼이 여러 개



##### 인라인 뷰

- FROM 절에서 사용되는 서브쿼리. **ORDER BY 사용 가능**



##### 뷰

- 테이블은 실제로 데이터를 가지고 있는 반면, 뷰는 실제 데이터를 가지고 있지 않음. 
- 가상 테이블이라고도 함.
- 실행 시점에 SQL 재작성하여 수행됨.



##### 뷰 사용 장점

1. **독립성**: 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨.
2. **편리성**: 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성 가능
3. **보안성**: 직원의 급여정보와 같이 숨기고 싶은 정보가 존재할 때 사용

```sql
CREATE VIEW V_PLAYER_TEAM AS SELECT ... ;
DROP VIEW V_PLAYER_TEAM;
```





---

### 제 5절. 그룹 함수

- ROLLUP
  - Subtotal을 생성하기 위해 사용
  - Grouping Columns의 수를 N이라고 했을 때 N+1 Level의 Subtotal이 생성 됨.
  - 인수 순서에 주의
- GROUPING
  - 집계 표시면 1, 아니면 0
- CUBE
  - 결합 가능한 모든 값에 대하여 다차원 집계를 생성
  - ROLLUP에 비해 시스템에 부하 심함
  - 2^N CUBE(A, B) = GROUPING SETS(A, B, (A, B ), ())
- GROUPING SETS
  - 인수들에 대한 개별 집계를 구할 수 있음
  - 다양한 소계 집합 생성 가능





---

### 제 6절. 윈도우 함수

- 행과 행간의 관계를 정의하거나 행과 행간을 비교, 연산하는 함수



##### 순위 관련 함수

- RANK: 동일한 값에 대해 동일한 순위 부여 (1,2,2,4)
- DENSE_RANK: 동일한 순위를 하나의 등수로 간주 (1,2,2,3)
- ROW_NUMBER: 동일한 값이라도 고유한 순위 부여 (1,2,3,4)



##### 집계 관련 함수

- SUM
  - 파티션별 윈도우의 합을 구할 수 있음
  - ex) 같은 매니저를 두고 있는 사원들의 월급 합
- MAX, MIN
  - 파티션별 윈도우의 최대, 최소 값
- AVG
  - 원하는 조건에 맞는 데이터에 대한 통계 값
    - ```ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING```
    - 현재 행을 기준으로 파티션 내에서 앞의 1건, 현재 행, 뒤의 1건을 범위로 지정
- COUNT
  - 조건에 맞는 데이터에 대한 통계 값
  - ex) 본인의 급여보다 50 이하가 적거나, 150 이하로 많은 급여를 받는 인원수



##### 행 순서 관련 함수 - SQL Server 지원 X

- **FIRST_VALUE**: 파티션별 윈도우의 처음 값
- **LAST_VALUE**: 파티션별 윈도우의 마지막 값
- **LAG**: 파티션별 윈도우에서 <u>**이전**</u> 몇 번째 행의 값
- **LEAD**: 파티션별 윈도우에서 **<u>이후</u>** 몇 번째 행의 값



##### 비율 관련 함수

- **RATIO_TO_REPORT**: 파티션 내 전체 SUM에 대한 행별 컬럼 값의 백분율을 소수점으로 구할 수 있음. >0, <=1
- **PERCENT_RANK**: 파티션별 윈도우에서 처음 값을 0, 마지막 값을 1로 하여 행의 순서별 백분율을 구함. 0>=, <=1
- **CUME_DIST**: 현재 행보다 작거나 같은 건수에 대한 누적백분율을 구함. >0, <=1
- **NTILE**: 파티션별 전체 건수를 인수 값으로 N등분한 결과를 알 수 있음



---

### 제 7절. DCL

- 유저 생성하고 권한을 제어할 수 있는 명령어



##### Oracle과 SQL Server의 사용자 아키텍처 차이

- Oracle
  - 유저를 통해 DB에 접속을 하는 형태
  - ID와 PW 방식으로 인스터늣에 접속하고, 그에 해당하는 스키마에 오브젝트 생성 등의 권한을 부여받음
- SQL Server
  - 로그인 생성 > 유저를 생성 > 로그인과 유저 매핑
  - Windows 인증 방식과 혼합모드 방식 존재



##### 시스템 권한

- 사용자가 SQL문을 실행하기 위해 필요로하고 적절한 궈한
- **GRANT**: 권한 부여
- **REVOKE**: 권한 취소

```sql
GRANT CREATE USER TO SCOTT;
CONN SCOTT/TIGER(ID/PW)
CREATE USER YJY IDENTIFIED BY KOREA7;
GRANT CREATE SESSION TO YJY;
GRANT CREATE TABLE TO YJY;
REVOKE CREATE TABLE FROM YJY;
```

- 모든 유저는 각각 자시닝 생성한 테이블 외에 다른 유저의 테이블에 접근하려면 해당 테이블에 대한 오브젝트권한을 소유자로부터 부여받아야 함.
- **ROLE**: 유저에게 알맞은 권한들을 한 번에 부여하기 위해 사용하는 것

```sql
CREATE ROLE LOGIN_TABLE;
GRANT CREATE TABLE TO LOGIN_TABLE;
DROP USER YJY CASCADE;
```

- **CASCADE**: 하위 오브젝트까지 삭제



---

### 제 8절. 절차형 SQL



##### 절차형 SQL

- SQL문의 연속적인 실행이나 조건에 따른 분기처리를 이용하여 특정 기능을 수행하는 저장 모듈을 생성 가능
- Procedure, User Defined Function, Trigger 등이 있음.



##### 저장 모듈

- PL/SQL 문장을 DB 서버에 저장하여 사용자와 애플리케이션 사이에서 공유할 수 있도록 만든 일종의 SQL 컴포넌트 프로그램
- 독립적으로 실행되거나 다른 프로그램으로부터 실행될 수 있는 완전한 실행 프로그램



##### PL/SQL 특징

1. Block 구조로 되어있어 각 기능별로 모듈화 가능
2. 변수, 상수 등을 선언하여 SQL 문장 간 값을 교환
3. IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램 가능
4. DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용 가능
5. PL/SQL은 Oracle에 내장되어 있으므로 호환성이 좋음
6. 응용 프로그램의 성능을 향상 시킴
7. Block 단위로 처리 -> 통신량 감소



##### DECLARE

- BEGIN~END 절에서 사용될 변수와 인수에 대한 정의 및 데이터 타입 선언부

##### BEGIN~END

- 개발자가 처리하고자 하는 SQL문과 여러가지 비교문, 제어문을 이용 필요한 로직 처리

##### EXCEPTION

- BEGIN~END절에서 SQL문이 실행될 때 에러가 발생하면 그 에러를 어떻게 처리할지 정의하는 예외 처리부



##### T-SQL

- 근본적으로 SQL Server를 제어하는 언어
- ```CREATE Procedure schema_NAME.Procedure_name```



##### Trigger

- 특정 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때, DB에서 자동으로 동작하도록 작성된 프로그램
- 사용자 호출이 아닌 DB 자동 수행



##### 프로시저와 트리거의 차이점

- **프로시저**
  - BEGIN~END절 내에 COMMIT, ROLLBACK과 같은 트랜잭션 종료 명렁어 사용 가능
  - EXECUTE 명령어로 실행
- **트리거**
  - **<u>BEGIN~END 절 내에 사용 불가.</u>**
  - 생성 후 자동 실행

