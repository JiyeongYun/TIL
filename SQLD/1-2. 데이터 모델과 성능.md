## 1-2. 데이터 모델과 성능

### 제 1절. 성능 데이터 모델링의 개요

##### 성능 데이터 모델링

- DB 성능향상을 목적으로 설계 단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

- 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따르재업무 비용을 최소화 할 수 있음
- 데이터 증가가 빠를수록 성능 저하에 따르성능 개선비용은 기하급수적으로 증가하게 됨



##### 성능 데이터 모델링 고려사항 순서

1. 데이터 모델링을 할 때 정규화를 정확하게 수행
2. DB 용량산정 수행
3. DB에 발생되는 트랜잭션의 유형을 파악
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼/서브타입 조정
6. 성능관점에서 데이터 모델을 검증



### 제 2절. 정규화와 성능

##### 함수의 종속성

- 데이터들이 어떤 기준 값에 의해 종속되는 현상



##### (-) 정규화

- 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것

- 1차 정규화
  - 같은 성격, 내용 컬럼이 연속될 때 컬럼 제거, 테이블 생성
- 2차 정규화
  - PK 복합키 구성일 때 부분적 함수 종속 관계 테이블 분리
- 3차 정규화
  - PK가 아닌 일반 컬럼에 의존하는 컬럼 분리



### 제 3절. 반정규화와 성능

##### (+) 반정규화

- 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상, 개발, 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
- 조회 시 디스크 I/O가 많거나 경로가 멀어 조인에 의한 **성능 저하를 막기 위해 수행**

- 일반적으로 **정규화**시 <u>*입력/수정/삭제*</u> 성능이 향상되며 **반정규화**시 *<u>조인 성능</u>*이 향상



##### 반정규화 절차

1. 반정규화 대상조사(범위처리빈도수, 범위, 통계성)
   - **자주 사용**되는 테이블에 접근하는 프로세스의 수가 많고 항상 **일정한 범위**만을 조회할 때
   - **대량의 범위**를 자주 처리하는 경우 처리 범위를 일정하게 줄이지 않으면 성능을 보장할 수 없을 때
   - **통계성 프로세스**에 의해 통계 정보를 필요로 할 때
   - 테이블에 **Join**개수가 많아 조회하기 어려울 때
2. 다른 방법유도 검토(뷰, 클러스터링, 인덱스 조정)
   - VIEW 사용 (VIEW가 성능향상 X)
   - 클러스터링 적용
   - 인덱스 조정
   - 파티셔닝(PK 성격에 따라 물리적 저장공간 분리)
   - 캐시
3. 반정규화 적용
   1. 테이블 반정규화
      - **테이블 병합**(1:1관계, 1:M관계, 슈퍼/서브타입)
      - **테이블 분할**(수직분할, 수평분할)
        - **수직분할**: 칼럼 단위 테이블을 디스크 I/O를 분산처리하기 우해 테이블을 1:1로 분리하여 성능향상
        - **수평분할**: 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우 단위로 테이블을 쪼갬
      - **테이블 추가**
        - **중복**: 원격조인을 제거하여 성능 향상
        - **통계**: SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능 향상
        - **이력**: 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 존재시켜 성능 향상
        - **부분**: 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들을 별도의 반정규화된 테이블을 생성하여 모으기
   2. 칼럼 반정규화
      - **중복칼럼** 추가: 조인할 때 성능저하를 예방하기 위해 중복된 칼럼을 위치시킴
      - **파생칼럼** 추가: 미리 값 계산
      - **이력테이블 칼럼** 추가: 대량 데이터에서 불특정 데이터를 조회할 때 기능성칼럼(최근값 여부, 시작과 종료일자 등)을 추가
      - **응용 시스템 오작동을 위한 칼럼** 추가: 실수로 인해 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
      - **PK에 의한 칼럼** 추가: 단일 PK안에서 특정 값을 별도로 조회하면 성능저하가 발생할 수 있으므로 일반속성으로 추가
   3. 관계 반정규화: **무결성 유지**
      - **중복관계 추가**
        - 데이터를 처리하기 위해 여러 경로를 거쳐 조인이 가능하지만 성능 저하가 발생할 수 있으므로 추가적인 관계를 맺는 방법



### 제 4절. 대량 데이터에 따른 성능

##### 로우체이닝

- 로우의 길이가 너무 길어 데이터 블로 ㄱ하나에 데이터가 모두 저장되지 않고 두 개 이상으 블록에 걸쳐 하나의 로우가 저장되어 있는 형태

##### 로우 마이그레이션

- 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 수정하는 것이 아니라 다르 블록의 빈 공간을 찾아 저장하는 방식

:arrow_right: 로우 체이닝과 로우 마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 DB 메모리에서 많은 I/O가 발생하여 성능저하 발생

:arrow_right: 트랜잭션을 분석하여 적절하게 1:1관계로 분리함으로써 성능향상이 가능하도록 해야함



##### PK에 의해 테이블을 분할하는 방법(파티셔닝)

1. **RANGE PARTITION**
   - 대상 테이블이 날짜 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리되는 경우
   - ex) 요금_0401
2. **LIST PARTITION**
   - 지점, 사업소 등 핵심적인 코드값으로 PK가 구성되어 있고, 대량의 데이터가 있는 테이블의 경우
   - ex) 고객_서울
3. **HASH PARTITION**
   - 지정된 HASH 조건에 따라 해시 알고리즘이 적용되어 테이블을 분리



##### 테이블에 대한 수평/수직분할의 절차

1. 데이터 모델링 완성
2. DB 용량 산정
3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리패턴 분석
4. 칼럼 단위로 집중화 된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블 분리하는 것을 검토하기
   - 컬럼이 많은 경우 :arrow_forward: 1:1 분리
   - 데이터가 많은 경우 :arrow_forward: 파티셔닝



### 제 5절. 데이터베이스 구조와 성능

##### 슈퍼/서브 타입 모델

- 업무를 구성하는 데이터를 공통점과 차이점의 특징을 고려하여 효과적으로 표현 가능
- 논리적인 데이터 모델에서 이용
- 슈퍼타입: 공통부분
- 서브타입: 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성



##### 슈퍼/서브 타입 데이터 모델의 변환기술

1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성(OneToOne Type)
2. 슈퍼타입+서브타입(Plus Type)
3. 전체를 하나로 묶어 트랜잭션이 발생할 경우는 하나의 테이블로 구성(Single Type, All in One Type)



##### 인덱스 특성을 고려한 PK/FK DB 성능향상

- 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 효율을 나타냄
- 앞쪽에 위치한 속성의 값이 가급적 '=' 아니면 최소한 범위 'BETWEEN', '<>'가 들어와야 효율적



### 제 6절. 분산 데이터베이스와 성능

##### 분산 DB란,

- 여러 곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB
- <u>**논리적으로 동일한**</u> 시스템에 속하지만, 컴퓨터 네트워크를 통해 **<u>물리적으로 분산</u>**되어 있는 데이터집합



##### 분산 DB를 만족하기 위한 6가지 투명성

1. **분할 투명성(단편화)**
   - 하나의 논리적 Relation이 여러 단편으로 분할되어 각 사본이 여러 site에 저장
2. **위치 투명성**
   - 사용하려는 데이터의 저장 장소 명시 불필요, 위치 정보가 시스템 카탈로그에 유지
3. **지역사상 투명성**
   - 지역 DBMS와 물리적 DB 사이의  Mapping 보장
4. **중복 투명성**
   - DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
5. **장애 투명성**
   - 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
6. **병행 투명성**
   - 다수 트랜잭션 동시 수행시 결과의 일관성 유지, TimeStamp, 분산 2단계 Locking 이용



##### 분산 DB 장단점

- 장점
  - 지역 자치성, 검증적 시스템 용량 확장
  - 신뢰성과 가용성
  - 효용성과 융통성
  - 빠른 응답속도, 비용 절감
  - 데이터의 가용성과 신뢰성 증가
  - 시스템 규모의 적절한 조절
  - 각 지역 사용자의 요구 수용 증대
- 단점
  - 비용증가
  - 오류의 잠재성 증대
  - 설계 관리의 복잡성
  - 불규칙한 응답속도
  - 통제의 어려움
  - 데이터 무결성 위협



##### 분산 DB 적용 기법

1. **테이블 위치 분산**
   - 설계된 테이블을 본사와 지사 단위로 분산
   - 위치별 DB 문서 필요
2. **테이블 분할 분산**
   - 각각의 테이블을 쪼개서 분산
   - **수평분할**: 지사별로 다를 때, 중복 X
   - **수직분할**: 각 테이블에 동일한 PK가 있어야 함.
3. **테이블 복제 분산**
   - 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
   - **부분복제**: 마스터 DB에서 테이블의 일부의 내용만 다르 지역이나 서버에 위치
   - **광역복제**: 마스터 DB 테이블의 내용을 각 지역이나 서버에 존재
4. **테이블 요약 분산**
   - 지역 간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
   - **분석요약**: 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 <u>**동일한 내용**</u>의 데이터를 이용하여 통합된 데이터를 산출하는 방식
     - ex) 판매실적 지사 A / 지사 B
   - **통합요약**: 분산되어 있는 <u>**다른 내용**</u>의 데이터를 이용하여 통합된 데이터를 산출하는 방식
     - ex) 판매실적 지사 A: C제품 / 지사 B: D제품



##### 분산 DB 설계를 고려해야 하는 경우

1. 성능이 중요한 사이트
2. 공통코드, 기준정보, 마스터 데이터의 성능향상
3. 실시간 동기화가 요구되지 않는 경우, Near Real Time 특징을 가지고 있는 경우
4. 특정 서버에 부하가 집중되어 부하를 분산해야 하는 경우
5. 백업 사이트를 구성하고자 하는 경우





